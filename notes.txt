Types

next: parsed
prev: parsed
dimensions: Array of number
charClass: { min: string, max: string, negated: boolean }
props: Array of { name: string, shallow: boolean }

parsed: everything below
alternationStart { type, end, next: Array of { props, regexPart: parsed }, prev }
alternationEnd { type, next, prev: Array of { props, regexPart: parsed } }
assertionStart { type, name: string, dimensions, condition: parsed | null, then: parsed, thenNot: parsed, prev }
assertionEnd { type, name: string, dimensions, condition: parsed | null, then: parsed, thenNot: parsed, next }
backreference { type, name: string, dimensions, next, prev }
capturingGroupStart { type, name: string, objName: string | null, shallow: boolean, next: parsed, prev }
capturingGroupEnd {type, next, prev: parsed }
conditionCheck: { condition: parsed, negated: boolean, lookbehind: boolean, next: parsed, prev: parsed }
group { type, arr: Array of [ boundary | string | charClass | Array of [ string | charClass ] ], next, prev }
subroutine { type, name: string, next, prev }
quantifierStart { type: [greedy|lazy|possesive]Start, min: number, max: number, special: boolean, props, end: parsed, next, prev }
quantifierEnd { type: [greedy|lazy|possesive]End, min: number, max: number, special: boolean, props, start: parsed, next, prev }


Stacks

subroutineStackItem
{ retObj: Object
, quantStateOpenStack: Array of quantStateStackItem
, quantStateClosedStack: Array of quantStateStackItem
, quantifierOpenStack: Array of quantifierStackItem
, quantifierClosedStack: Array of quantifierStackItem
, ignoreCase: boolean
, next: parsed | null
, depth: number
}

quantifierStackItem
{ captrGroupOpenStack: Array of captrGroupStackItem
, captrGroupClosedStack: Array of captrGroupStackItem
, start: number
, end: number
, flag: boolean
, props
, special
, depth: number
}

captrGroupStackItem
{ name: string
, objName
, shallow: boolean
, posStart: number
, posEnd: number
}


new quantifier - captrGroup qNested; qItem
push                         pop
start !== end; start > 0     start === end; end === 0
old quantifier - captrGroup qBreak;
push                         pop
start === end; start > 0     start === end; end > 0


TODO
1.  Unicode? http://www.regular-expressions.info/unicode.html
2.  Second mode of matching? Matches will be organized into array, including parts
    of the string that are not captured, object properies will not be strings,
    but integer indexes of the array. Concatenating the array will create the
    substring from starting to ending position.
    Example:
    { arr [ "<", "i", ">", "Hello!", "</i>" ]
    , loc: { ... }
    , input: "<i>Hello!</i>"
    , name: { ... }
    , htmlTag: 1
    , attributes: []
    , content: 3
    }
3.  Option to throw when match is not found, with descriptive message like: Expected one of: X, Y, Z found "("
4.  Detect possible catastrophic bactracking, provide option to disable such
    regexes so this library can be used without worrying about ReDos (I have
    no idea whether this is possible)
    http://www.regular-expressions.info/catastrophic.html
7.  \p{UnicodeSomething} - implement if/when javascript implements this?
8.  \x{UnicodeCodePoint} - implement if/when javascript implements this?
9.  Should this be valid?
    (abc(;(:num:\d+)zzz(=num);){3,}(=num[0])def(, )?)*(=num[-1][-1])
10. RegexGroup.finish() - forbids futrher modification of this RegexGroup, can do
    further optimizations maybe?
12. Alternation shouldn't manipulate quantifierStack if it contains no captrGroups?
13. Assertion and backreference that work for all values in array, like (=ref[])
14. Encode regex as array of integers?
15. How should replacing work?
16. Throw when capturing group has the same "input", "loc" or "name".